## Touraine Tech 2026 .[chapter]
# Bienvenue ! üëã

/*
 Bienvenue tout le monde !

 Il y aura quelques QR-code d'articles donc tenez-vous pr√™t-es !
*/


## Rust ü¶Ä est connu pour √™tre un langage qui favoriserait le "bas-niveau"...

!image(assets/embedded_rust_example.png)

/*
 Ajouter une image d'exemple "embedded"
*/


## Pour des masochistes f√©rus d'optimisations m√©moire...

!image(assets/borrow_checker_meme.jpeg)

/*
 Meme borrow checker
*/

## √Ä la syntaxe souvent qualifi√©e d'exigeante, voire de "cryptique"... ü§Ø

!image(assets/coerce_what_now.png)

## Tout ceci est p'tet vrai, mais que c'est pas pour √ßa que Rust m'int√©resse

!image(assets/bernie_rust.jpeg)

/*
 C'est vrai, en plus
*/


## Des outils et des crabes .[chapter]
# ü¶ÄRustü¶Ä
# pour des applications m√©tiers

/*
 "applications m√©tiers", c'est √† dire de bonnes vieilles applications qui ont pour objectif la mod√©lisation de processus qui ont des cons√©quences sur la vie r√©elle, sans pour autant d√©pendre d'un mat√©riel sp√©cifique.
Donc pas d'embarqu√©, pas vraiment de contraintes en dehors de ce qu'on conna√Æt: des WebApps qui causent avec une base de donn√©es et 2/3 trucs autour (de l'IAM, par ex)
*/


## Un syst√®me de types expressif

/*
 √Ä vos souhaits. Promis je ne vais pas vous expliquer le Arc ou le Mutex
*/


## La base: Structs, et "Newtypes" .[chapter]


## Un cas ultra-classique:

```rust
pub struct User {
    pub email: String,
}

fn ma_fonction(user: User) {
  if !user.email.contains("@") {
     // Gestion de l'erreur, etc.
  }
  // On continue...

  // Possible, mais pas voulu -> Bug !
  let city: String = user.email
}
```

/*

Nul. On va devoir multiplier les types partout.
Re-nul. "String", √ßa ne veut rien dire, on met un email dans une variable qui contient une ville ?
Non mais allo, quoi !

*/


## Encoder la logique m√©tier, le r√™ve ! üòå

```rust
use crate::domain::UserEmail;

pub struct User {
    // Attendez‚Ä¶c'est quoi √ßa ?
    pub email: UserEmail,
}
```

/*
 Exemple canonique, on veut cr√©er un utilisateur, on a besoin de son email.

Ici, pas de String qui voudrait dire tout et n'importe quoi. On type tout fortement (sinon, √ßa va hurler √† la compilation)
*/

## On "impl"√©mente la logique pour traiter les cas :

```rust
use validator::ValidateEmail;

#[derive(Debug)]
pub struct UserEmail(String);

impl UserEmail {
    pub fn parse(s: String) -> Result<UserEmail, String> {
        if s.validate_email() {
            Ok(Self(s))
        } else {
            Err(format!("{} is not a valid user email", s))
        }
    }
}
```

/*
Un newtype va "emballer" un type (ici String)

Tr√®s pratique car un UserEmail n'est pas un String, ni n'est √©quivalent √† un autre NewType(String) -> compilateur pas content si on m√©lange -> pas de Duck Typing

On d√©l√®gue la validation elle-m√™me √† une "crate" (on reviendra l√†-dessus), un lib externe, quoi
*/

## Comment on valide √ßa ? Avec des tests ! ü§©

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn email_missing_at_symbol_is_rejected() {
        let email = "stephanedomain.com".to_string();
        assert_err!(UserEmail::parse(email));
    }

    #[test]
    fn email_missing_subject_is_rejected() {
        let email = "@domain.com".to_string();
        assert_err!(UserEmail::parse(email));
    }
}
```

/*
 On reviendra l√†-dessus, mais les tests sont colocalis√©s avec le code.
*/


## Un newtype n'est pas √©gal √† un autre type !

```rust
pub struct Address(String);
pub struct UserEmail(String);

pub struct User { pub email: UserEmail }

let my_user = User {
  // üí•Erreur ! Pas un UserEmail, mais un String !
  email: "steph@mydomain.com"
}

let my_user = User {
  // üí•Erreur ! Pas un UserEmail, mais un Address !
  email: Address("steph@mydomain.com")
}
```

/*
 Et c'est ce qu'on veut !
*/


## Il faut utiliser le newtype pr√©vu :

```rust
use crate::domain::UserEmail;

pub struct User {
    pub email: UserEmail,
}

let my_user = User {
  // Ok üëç
  email: UserEmail::parse("steph@mydomain.com")?;
}
// Note: Pour l'instant le `?` c'est "magique" ü™Ñ
```

## .[full-image]

!image(assets/parse_dont_validate.png)

/*
Un principe fondamental en Rust.
Li√© √† la philosophie Impureim: on veut au plus possible travailler dans un univers "pur", sans effects secondaires, qu'on ma√Ætrise.
On _encode notre logique_ -> Type Driven Development.
*/


## Une autre mani√®re de le voir:

!image(assets/impureim-sandwich.png)


## L'Œë et l'Œ© du Type Driven Development‚Ä¶ .[chapter]


# Le Pattern Matching


## Exemple avec un enum tout b√™te :

```rust
pub enum LoginError {
    AuthenticationError(String),
    SSOErrorCode(u32),
    UnexpectedError(String),
}
```


## L'op√©rateur \``match`\`

```rust
fn my_function(e: LoginError) {
    match e {}
          +-----------------------------------------------------------------------------+
}         |missing match arm: `AuthenticationError(_)`, `SSOErrorCode(_)` and           |
          |`UnexpectedError(_)` not covered (rust-analyzer E0004)                       |
          |-----------------------------------------------------------------------------|
          |non-exhaustive patterns: `LoginError::AuthenticationError(_)`, `LoginError:: |
          |SSOErrorCode(_)` and `LoginError::UnexpectedError(_)` not covered            |
          |the matched value is of type `LoginError`                                    |
          |                                                                             |
          |Related information:                                                         |
          |                                                                             |
          |  * main.rs#463,10: `LoginError` defined here                                |
          |  * main.rs#470,12: ensure that all possible cases are being handled by      |
          |adding a match arm with a wildcard pattern, a match arm with multiple or-    |
          |patterns as shown, or multiple match arms: ` {                               |
          |        LoginError::AuthenticationError(_) | LoginError::SSOErrorCode(_) |   |
          |LoginError::UnexpectedError(_) => todo!(),                                   |
          |    }`                                                                       |
          |                                                                             |
          | (rustc E0004)                                                               |
          |-----------------------------------------------------------------------------|
          |https://doc.rust-lang.org/error-index.html#E0004                             |
          +-----------------------------------------------------------------------------+
```


## Fort heureusement on a ce qu'il faut avec le LSP de Rust üòå

```rust
fn my_function(e: LoginError) {
    match e {}
}            +Choose action------+
             |1. Fill match arms |
             +-------------------+
```


## Et y a plus qu'√† remplir !

```rust
fn my_function(e: LoginError) {
    match e {
        LoginError::AuthenticationError(_) => todo!(),
        LoginError::SSOErrorCode(_) => todo!(),
        LoginError::UnexpectedError(_) => todo!(),
    }
}
```

## On peut laisser la vraie implem' pour plus tard

```rust
fn my_function(e: LoginError) {
    match e {
        LoginError::AuthenticationError(_) => todo!("Ah, pas cool üò±"),
        LoginError::SSOErrorCode(_) => todo!("Oul√† ! Encore moins cool üòì"),
        LoginError::UnexpectedError(_) => todo!("Alors l√† jsp moi‚Ä¶ üòÖ"),
    }
}
```


## On peut √™tre arbitrairement complexe

```rust
fn my_function(e: LoginError) {
    match e {
        LoginError::AuthenticationError(auth)
          if auth.contains("network") => todo!("Ah, pas cool üò±")
        LoginError::SSOErrorCode(c)
          if c > 42 && c < 1337 => todo!("Oul√† ! Encore moins cool üòì"),
        LoginError::UnexpectedError(error)
          if error.is_empty() => todo!("Alors l√† jsp moi‚Ä¶ üòÖ"),
    }
}
```

## Mais le compilateur veille...

```rust
fn my_function(e: LoginError) {
    match e {
          +------------------------------------------------------------------------------+
        Lo|missing match arm: `AuthenticationError(_)` not covered (rust-analyzer E0004) |
          |------------------------------------------------------------------------------|
        } |non-exhaustive patterns: `LoginError::AuthenticationError(_)` not covered     |
        Lo|the matched value is of type `LoginError`                                     |
        Lo|                                                                              |
    }     |Related information:                                                          |
}         |                                                                              |
          |  * main.rs#463,10: `LoginError` defined here                                 |
          |  * main.rs#475,76: ensure that all possible cases are being handled by       |
          |adding a match arm with a wildcard pattern or an explicit pattern as shown: `,|
          |        LoginError::AuthenticationError(_) => todo!()`                        |
          |                                                                              |
          | (rustc E0004)                                                                |
          |------------------------------------------------------------------------------|
          |https://doc.rust-lang.org/error-index.html#E0004                              |
          +------------------------------------------------------------------------------+
```


## Voyez-vous le probl√®me, ici ?

```rust
pub enum Direction {
    North,
    South,
    East,
    West,
}
type Coordinates<'a> = (&'a u32, &'a u32);

pub fn move_player((&x, &y): Coordinates, direction: &Direction) {
    match ((x, y), direction) {
        ((0, 0), _) => todo!("Origine du plan, rien √† faire"),
        ((13, 10), Direction::South) => todo!("Ah non y a l'oc√©an par-l√† !"),
    }
}
```


## Le compilateur est plus vigilant que vous üò∏

```rust
pub fn move_player((&x: u32, &y: u32): Coordinates, direction: &Direction) {
    match ((x, y), direction) {
          +-----------------------------------------------------------------------------+
        ((|non-exhaustive patterns: `((1_u32..=12_u32, _), _)` and `((14_u32..=u32::MAX,|
        ((|_), _)` not covered                                                          |
    }     |the matched value is of type `((u32, u32), &Direction)`                      |
}         |                                                                             |
          |Related information:                                                         |
          |                                                                             |
          |  * main.rs#412,77: ensure that all possible cases are being handled by      |
          |adding a match arm with a wildcard pattern, a match arm with multiple or-    |
          |patterns as shown, or multiple match arms: `,                                |
          |        ((1_u32..=12_u32, _), _) | ((14_u32..=u32::MAX, _), _) => todo!()`   |
          |                                                                             |
          | (rustc E0004)                                                               |
          |-----------------------------------------------------------------------------|
          |https://doc.rust-lang.org/error-index.html#E0004                             |
          +-----------------------------------------------------------------------------+
```


## Et finalement, tout s'arrange üòâ

```rust
pub enum Direction {
    North,
    South,
    East,
    West,
}
type Coordinates<'a> = (&'a u32, &'a u32);

pub fn move_player((&x, &y): Coordinates, direction: &Direction) {
    match ((x, y), direction) {
        ((0, 0), _) => todo!("Origine du plan, rien √† faire"),
        ((13, 10), Direction::South) => todo!("Ah non y a l'oc√©an par-l√† !"),
        ((_,_) , _) => todo!("Autres cas √† traiter plus tard")
    }
}
```


## Le moment o√π √ßa a fait 'üí°' dans ma t√™te .[chapter]
# Les "Bo√Ætes" de Rust


## "Mais, attends, c'est quoi Result, Ok, et Err ?"

```rust
use validator::ValidateEmail;

#[derive(Debug)]
pub struct UserEmail(String);

impl UserEmail {               +-------------------------+
    pub fn parse(s: String) -> |Result<UserEmail, String>| {
                               +-------------------------+
        if s.validate_email() {
           +-----------+
           |Ok(Self(s))|
           +-----------+
        } else {
           +-----------------------------------------------+
           |Err(format!("{} is not a valid user email", s))|
           +-----------------------------------------------+
        }
    }
}
```

## Moment Kahoot !

!image(assets/kahoot_billion_dollar_mistake.jpg)

/*
 Toutes les r√©ponses sont valables, mais une l'est historiquement
*/


## H√© oui, c'est bien Null:

!image(assets/billion_dollar_mistake.png)

/*
L'ajout de `null` √† Algol W, et sa r√©plication dans (presque) tous les languages qui l'ont suivi
 Dont Javascript, et c'est la raison pour laquelle Microsoft d√©pense une fortune dans mon linter pr√©f√©r√© (TypeScript)
*/

## Certains langages font ce qu'ils peuvent‚Ä¶

!image(assets/nilnilnil.jpeg)

/*
 En Rust, pas de gestion de erreurs en tant qu'exceptions (Java/JS), ni en tant que valeur (Nil)
*/

## Bienvenue dans le multivers !

!image(assets/result.png)

/*
 Either Monad, mon amour
*/


## Un Result √©tant un Enum (`Ok`|`Err`), on peut le `match`

```rust
// validate_credentials:
//   (Credentials) -> Result<Uuid, LoginError>
match validate_credentials(credentials).await {
}                       +Choose action -----+
                        |1. Fill match arms |
                        +-------------------+
```


## Et y a plus qu'√† remplir, ou √† `todo!`

```rust
// validate_credentials:
//   (Credentials) -> Result<Uuid, LoginError>
match validate_credentials(credentials).await {
    Ok(_) => todo!("rajouter le cas o√π tout est ok"),
    Err(_) => todo!("rajouter la gestion d'erreur"),
}
```


## Finalement, on met le code final:

```rust
match validate_credentials(credentials).await {
  Ok(user_id) => {
    return HttpResponse::SeeOther()
      .insert_header((LOCATION, "/admin/dashboard"))
      .finish());
  }
  Err(e) => {
    return login_redirect(LoginError::AuthError(e));
  }
}
```

## "On est oblig√©s de matcher √† chaque fois un Result ?"


## Non, on peut utiliser par ex. `.unwrap()` pour √ßa

```rust
// Dans ce cas-ci, on est persuad√©s qu'on
// aura toujours un port disponible
let port = listener.local_addr().unwrap().port();
```


## Mais pourquoi qu'on s'inflige `match`, alors ?

!image(assets/unwrap-me-i-double-dare-you.jpg)


## Et m√™me les plus gros se font avoir :

!image(assets/cloudflare-incident.png)


## R√©servez `.unwrap()` pour le code de test et apprenez √† propager ou g√©rer les `Result`

```rust
fn my_function() -> Result<PortNumber, Error> {
  /* In this case, we SHOULD have an IP address. */
  /* If not, bubble up the error upwards */
  let port = listener.local_addr()?.port();
  return port;
}
```


## D'ailleurs, en parlant d'erreurs...


## `anyhow` et `thiserror`, les jumeaux surdou√©s de la gestion d'erreur.

/*
Si les erreurs sont relous √† g√©rer, vous les g√©rerez mal, et c'est l√† qu'il y aura des bugs.
Fort heureusement, la communaut√© Rust a tout pr√©vu ^^
*/


## `thiserror`, les erreurs faciles √† d√©crire :

```rust
use thiserror::Error;
#[derive(Error, Debug)]
pub enum DataStoreError {
  #[error("data store disconnected")]
  Disconnect(#[from] io::Error),
  #[error("the data for key `{0}` is not available")]
  Redaction(String),
  #[error("invalid ({expected:?}, found {found:?})")]
  InvalidHeader {
      expected: String,
      found: String,
  },
  #[error("unknown data store error")]
  Unknown
}
```

/*
thiserror va automatiquement faire le lien entre des erreurs et leur traduction (Display), juste avec des proc macros (donc zero cost abstraction).
Ce code est tir√© de la doc officielle de la crate.
Notez d'ailleurs l'enum: toutes les erreurs sont exhaustivement d√©crites ici (permettant d'utiliser le pattern matching)
*/

## `anyhow`, les erreurs faciles √† cr√©er :

```rust
use anyhow::{Context, Result};

/*  Le Result ne pr√©cise m√™me plus le type d'erreur */
/*  car ce sera un `anyhow::Error` üëå */
fn main() -> Result<()> {

  /*  .context permet d'emballer l'erreur avec‚Ä¶du contexte üòÅ */
  it.detach().context("Failed to detach the thing")?;

  /*  L'utilisation de `?` veut simplement dire: */
  /*  Si c'est une `Err` alors on bubble up ! */
  /*  Sinon on "ouvre" la bo√Æte `Ok` et on prend son contenu */
  let content = std::fs::read(path)?;
}
```

/*
C'est plus simple quand on n'a plus √† y penser.
Note: Ce code est tir√© de la doc officielle de la crate.
*/


## ¬´ L√† o√π on va, il n'y a pas d'abstract public void final static ‚Ä¶ ¬ª .[chapter]
# Traits, la POO turbo-charg√©e 

/*
 Pas d'h√©ritage, pas de "abstract static final etc.". Une composition simple de m√©thodes
*/


## .[full-image]

```rust
pub struct RecipientEmail(pub String);
pub struct SenderEmail(pub String);

pub trait PaymentProcessor {
    fn send_payment(
        recipient: &RecipientEmail,
        sender: &SenderEmail,
    ) -> Result<(), anyhow::Error>;
}

pub struct MyPaymentProcessor {}

impl PaymentProcessor for MyPaymentProcessor {}
   +------------------------------------------------------------------------------+
   |not all trait items implemented, missing: `send_payment`                      |
   |missing `send_payment` in implementation                                      |
   |                                                                              |
   |Related information:                                                          |
   |                                                                              |
   |  * main.rs#422,5: `send_payment` from trait                                  |
   |  * main.rs#431,47: implement the missing item: `fn send_payment(_:           |
   |&RecipientEmail, _: &SenderEmail) -> std::result::Result<(), anyhow::Error> { |
   |todo!() }`: `fn send_payment(_: &RecipientEmail, _: &SenderEmail) ->          |
   |std::result::Result<(), anyhow::Error> { todo!() }`                           |
   +------------------------------------------------------------------------------+

```


## Comme pour les enums, on peut utiliser le puissant LSP de Rust

```rust
pub struct MyPaymentProcessor {}

impl PaymentProcessor for MyPaymentProcessor {}
      +Choose action --------------+
      |1. Implement missing members|
      +----------------------------+
```



## Et on met ensuite l'implem' qu'on veut:

```rust
pub struct RecipientEmail(pub String);
pub struct SenderEmail(pub String);

pub trait PaymentProcessor {
    fn send_payment(
        recipient: &RecipientEmail,
        sender: &SenderEmail,
    ) -> Result<(), anyhow::Error>;
}

pub struct MyPaymentProcessor {}
impl PaymentProcessor for MyPaymentProcessor {
    fn send_payment(
        recipient: &RecipientEmail,
        sender: &SenderEmail,
    ) -> Result<(), anyhow::Error> {
        todo!("Payment instructions from {sender} to {recipient} go here !")
    }
}
```


## Les traits "standards"

## Un exemple simple: J'ai une `LoginError`, et je veux la d√©boguer

/*
 Par exemple, j'ai un test qui plante et je veux comprendre pourquoi
*/


## Une "fonction" super pratique: `dbg!(my_error)`

```rust
let my_error = LoginError::AuthError("Oul√† !");
dbg!(&my_error)
```

## Sauf que LoginError n'est pas un type √©l√©mentaire...

```rust
+---------------------------------------------------------+
|`LoginError` doesn't implement `std::fmt::Debug`         |
|add `#[derive(Debug)]` to `LoginError` or manually `impl |
|std::fmt::Debug for LoginError`                          |
|                                                         |
|Related information:                                     |
|                                                         |
|  * error.rs#53,18: required by a bound in `Error`       |
|  * post.rs#18,1: consider annotating `LoginError` with  |
|    `#[derive(Debug)]`                                   |
|                                                         |
| (rustc E0277)                                           |
|---------------------------------------------------------|
|https://doc.rust-lang.org/error-index.html#E0277         |
+---------------------------------------------------------+
```

/*
 Regardez la puissance du message d'erreur !
*/


## D√©river, simple et bien pratique dans 90% des cas :

```rust
#[derive(Debug)]
pub enum LoginError {
    AuthError(Error),
    UnexpectedError(Error),
}
```

## Ok pour les cas de base, mais comment impl√©menter explicitement `Debug` ?

## Encore une fois, le LSP est l√† pour nous aider üòç

```rust
pub enum LoginError {
    AuthError(String),
    UnexpectedError(String),
}

impl std::fmt::Debug for LoginError {}
              +Choose action --------------+
              |1. Implement missing members|
              +----------------------------+
```

## On obtient une impl√©mentation "par defaut", qu'on peut alors customiser ü§§

```rust
impl std::fmt::Debug for LoginError {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    match self {
      Self::AuthError(arg0) =>
          f.debug_tuple("AuthError").field(arg0).finish(),
      Self::UnexpectedError(arg0) =>
          f.debug_tuple("UnexpectedError").field(arg0).finish(),
    }
  }
}
```

## Et on y met ce qu'on veut (tant qu'on respecte le Trait)

```rust
impl std::fmt::Debug for LoginError {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        writeln!(f, "{}\n", e)?;
        let mut current = e.source();
        while let Some(cause) = current {
            writeln!(f, "Caused by:\n\t{}", cause)?;
            current = cause.source();
        }
        Ok(())
    }
}
```

/*
 Ici j'utilise .source() pour remonter la cha√Æne d'erreurs
*/


## Ce qui nous permet d'avoir un d√©tail de l'erreur bien plus clair en debug :

```log
Failed to log in user.
Caused by:
    Failed to retrieve user informations
Caused by:
    error returned from database
Caused by:
    table "user" does not exist
```


## La "blanket implementation" d'un Trait pour un Type

!image(assets/cozy-pepe.png)

/*
 L'art d'impl√©menter des m√©thodes pour d'autres types.
*/


## Id√©e: √áa serait pas mal de facilement "convertir" un type en un autre ü§î

```rust
struct FormData {
    key: String,
}

let secure_key: SecurityKey = form.key
  .try_into()
  .map_err(error_400)?;
```

/*
 Et s'√©viter ainsi d'avoir √† appeller le .parse() qu'on a √©crit
*/


## `SecurityKey` a une _blanket implementation_ pour le type `String` üí°

```rust
impl TryFrom<String> for SecurityKey {
type Error = anyhow::Error;
fn try_from(s: String) -> Result<Self, Self::Error> {
    if s.is_empty() {
        anyhow::bail!("The security key cannot be empty.")
    }
    let min_length = 50;
    if s.len() < min_length {
        anyhow::bail!(r#"The security key must be
        longer that {min_length} characters"#)
    }
    Ok(Self(s))
}}
```

/*
 Suffit d'importer `SecurityKey` et cet `impl` et le tour est jou√© !
*/


## Et des types/traits/bo√Ætes comme √ßa, vous en avez PLEIN, dans Rust ü§©
- `Option` (`Some<‚Ä¶>` ou `None`)
- `Debug` vs `Display`
- `Deref`
- `Drop`


## Architecture Hexagonale

/*
 Le mot est l√¢ch√© !
*/


## Rappel √† toutes fins utiles:

!image(assets/hexagonal-architecture-diagram.jpg)


## Donc, si vous avez bien suivi‚Ä¶

!image(assets/hexagonal-architecture-diagram-in-rust.png)


## Mais, en vrai‚Ä¶

!image(assets/hexagonal-architecture-diagram-in-TRUE-rust.png)


## Et c'est ok !

```rust
fn process_data<F, B>(foo: F, bar: B) -> String
where
    F: Clone + Debug,
    B: Display + PartialEq,
{
    // Function implementation
    format!("{:?} - {}", foo, bar)
}
```

## ‚¨¢ + ü¶Ä = üíì

!image(assets/master-hexa-architecture-in-rust.png)

## Un √©cosyst√®me de librairies applicatives solide, complet, et agr√©ablement document√©

## Il faut qu'on parle de `sqlx`

!image(assets/sqlx-simple.png)

## Et √ßa peut m√™me √™tre tr√®s complexe !

!image(assets/sqlx-complex.png)

## Les autres poids lourds : serde, tera, chrono, et bien d'autres !

## Les Frameworks haut-niveau de Rust ü¶Ä

## Les v√©n√©rables axum et actix-web

/*
 Ont popularis√© d'autres crates √† travers elles, et cette autre fa√ßon de faire du Rust Applicatif
*/


## Axum

!image(assets/axum.png)

/*
 Mon premier, tr√®s simple (type Express), qui a bien √©volu√© depuis
*/


## Actix-web

!image(assets/actix-json.png)

/*
 Les extracteurs Actix c'est une tuerie, et vous pouvez faire les votres (par ex, un extrateur de Cookie de Session)
*/


## Mais le monde des (c)rustac√©s va vite, tr√®s vite‚Ä¶

## Dioxus, le framework isomorphique qui monte !

!image(assets/dioxus-intro.png)

## On peut litt√©ralement tout faire avec ü§Ø

!image(assets/dioxus-montage.png)

## Vous venez plut√¥t de Rails et RoR ? No problemo‚Ä¶

!image(assets/loco-rs-montage.png)

## Une mani√®re de tester les applications qui n'a pas son pareil

!image(assets/cargo-test-colocalized.png)

## La doc des projets Rust est‚Ä¶ *chef kiss* ü§å

!image(assets/adder-doc.png)

## TOUT est "as code":
!image(assets/rust-doc-as-code.png)

/*
Plus vous mettez d'info dans le code, plus √ßa renvoie de la valeur.
Et les LLMs adoooorent √ßa
*/

## `cargo doc` , tout simplement

!image(assets/cargo-doc-tests.png)


## Oh, et ils sont *par d√©faut* test√© par `cargo test` üòé

!image(assets/cargo-doc-passing-test.png)


## Votre doc ne fait pas que d√©crire vos invariants, elle les contr√¥le ! üí™

!image(assets/cargo-doc-failing-test.png)


## Tests d'Int√©gration ?
Facile ! On les met dans `/tests` (avec du code de setup si besoin)

!image(assets/integration_test.png)

## D'ailleurs‚Ä¶ Il faut qu'on parle de Wiremocks ü§©

## Un cas difficile √† tester : L'idempotence

!image(assets/idempotency.gif)

## R√©sultat, avec Wiremocks:

!image(assets/wiremock-idempotence.png)

## Si vous voulez aller plus loin...

(parce qu'il y en a encore plein, des dingueries comme √ßa üòÖ, dans Rust)

/*
 Property testing, optimisations diverses, hyperfine, et bien d'autres !
*/


## Zero2Production in Rust ü§©

!image(assets/z2p-book.png)

## Learn Rust with linked lists

!image(assets/learn-rust-with-linked-lists.png)

## YouTube: Let's Get Rusty !

!image(assets/lets-get-rusty.png)
